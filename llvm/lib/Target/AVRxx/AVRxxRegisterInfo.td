//===-- AVRxxRegisterInfo.td - AVR Registers --------------*- tablegen -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
//  Describe the AVR register file
//===----------------------------------------------------------------------===//


//===----------------------------------------------------------------------===//
//  8-bit general purpose registers
//===----------------------------------------------------------------------===//

// Common traits of all AVR registers
class AVRxx_Register_Traits {
  string Namespace = "AVRxx";
}

// Generate all of the 8-bit architectural registers
multiclass AVRxx_Byte_Registers {

  // Generate the 32 General Purpose registers. GDB simply defines the DWARF
  // number the same as each GP register's R number.
  foreach _register_index = 0...31 in {
    def R#_register_index:
          Register<
            "r"#_register_index,  // The ASM name is typically lowercase
            ["R"#_register_index] // Provide uppercase as an alternate name
          >,
          DwarfRegNum<[   // The DWARF number matches the register index
            _register_index
          ]>,
          AVRxx_Register_Traits {
      let HWEncoding{4-0} = _register_index;
    }
  }

  // Generate the 8 Special/IO registers that may be addressed by the
  // translator. GDB DWARF numbers are not so easy for these. GDB maps
  // SREG, SP (the 16-bit register tuple) and PC to numbers 32, 33, and
  // 34 respectively. DWARF generated by avr-gcc denotes a call return
  // address by number 36, but this is not an actual register. GDB adds
  // a pseudo-register (36 - AVR_DWARF2_PC_REGNUM) to map this faked
  // register in the .debug_frame. It is named "LR" (link register).
  foreach _register_index = 0...7 in {
    defvar  _register_name = [ /* Index  Addr  Description            */
              "SREG" ,         /*  [0]   0x3F  Status Register        */
              "SPH"  ,         /*  [1]   0x3E  Stack Pointer High     */
              "SPL"  ,         /*  [2]   0x3D  Stack Pointer Low      */
              "EIND" ,         /*  [3]   0x3C  Extended Indirect Jump */
              "RAMPZ",         /*  [4]   0x3B  Extended RAM Ptr Z     */
              "RAMPY",         /*  [5]   0x3A  Extended RAM Ptr Y     */
              "RAMPX",         /*  [6]   0x39  Extended RAM Ptr X     */
              "RAMPD",         /*  [7]   0x38  Extended RAM Ptr D     */
    ];
    def _register_name[_register_index]:
          Register<
            _register_name[_register_index],
            !cond(  // SREG has an altername name FLAGS, others have none.
              !eq(_register_index,0): ["FLAGS"],
              true: []
            )
          >,
          DwarfRegNum<[
            !add(32,_register_index)
          ]>,
          AVRxx_Register_Traits {
      let HWEncoding{6-0}  =  !sub(0x3F, _register_index);
    }
  }
}
defm "": AVRxx_Byte_Registers;




def TestClass: RegisterClass<"AVRxx", [i8], 8, (add R16)> {
}
